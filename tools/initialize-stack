#!/bin/bash

DOMAIN_NAME=
EXTERNAL_DOMAIN_NAME=
EXTERNAL_HOSTED_ZONE_ID=
PROFILE=
REGION=
STACK_NAME=
STACK_DIR=
PROJECT=
ENVIRONMENT=
OPENSSL=/usr/bin/openssl
MODE=reuse


USAGE="Usage: $(basename $0)
	--region/-r region
	--internal-domain-name/-d internal-domain-name
	--external-domain-name/-x external-domain-name
	--profile/-p aws-profile
	--project/-p project
	--environment/-e environment
	--mode/-m [reuse | create-new ]
	"

function parseCommandLine() {
	while [ $# -ge 2 ] ; do
		OPT=$1
		OPTARG=$2
		shift 2
		case $OPT in
			--region|-r)
				REGION=$OPTARG
				;;
			--internal-domain-name|-d)
				DOMAIN_NAME=$OPTARG
				STACK_NAME=$(echo $DOMAIN_NAME | sed -e 's/[^a-zA-Z0-9]//g')
				STACK_DIR=stacks/$STACK_NAME
				;;
			--external-domain-name|-x)
				EXTERNAL_DOMAIN_NAME=$OPTARG
				;;
			--profile|-p)
				PROFILE=$OPTARG
				;;
			--project|-t)
				PROJECT=$OPTARG
				;;
			--environment|-e)
				ENVIRONMENT=$OPTARG
				;;
			--mode|-m)
				MODE=$OPTARG
				;;
			*)
				echo $USAGE >&2
				exit 1
				;;
		esac
	done

	if [ $# -gt 0 ] ;then
		echo "$USAGE" >&2
		echo "	incorrect options" >&2
		exit 1
	fi

	[ -z "$DOMAIN_NAME" ] && echo "$USAGE, -d is missing" >&2 && exit 1
	[ -z "$EXTERNAL_DOMAIN_NAME" ] && echo "$USAGE, -x is missing" >&2 && exit 1
	[ -z "$PROFILE" ] && echo "$USAGE, -p is missing"  >&2 && exit 1
	[ -z "$PROJECT" ] && echo "$USAGE, -t is missing"  >&2 && exit 1
	[ -z "$ENVIRONMENT" ] && echo "$USAGE, -e is missing" >&2 && exit 1
	[ -z "$REGION" ]  && echo "ERROR: no default region specified and no region (-r) specified." >&2 && exit 1

	if [ ! -d $STACK_DIR ] ; then
		mkdir -p $STACK_DIR
	fi

	if [ -f $STACK_DIR/stack-parameters ] ; then
		echo "ERROR: stack-parameters file already exist. this script is to initialize a new stack." >&2
		exit 1
	fi

	setOpenSSL
	checkLogin
}

function checkLogin() {
	aws  --profile $PROFILE --region $REGION ec2 describe-instances > /dev/null || exit 1
}

function setOpenSSL() {
	if [ "$(uname)" == "Darwin" ] ; then
		OPENSSL=/usr/local/bin/openssl
	else
		OPENSSL=/usr/bin/openssl
	fi
	[ ! -x "$OPENSSL" ] && echo "ERROR: $OPENSSL not installed." >&2 && exit 1
}


function getHostedZoneId() {
	# make sure it has a dot at the end..
	DOMAIN=$(echo $1 | sed -e 's/\.$//' -e 's/$/./')
        aws --profile $PROFILE --region $REGION route53 list-hosted-zones  \
		| jq --arg domain "$DOMAIN" -r '.HostedZones[] | select(.Name == $domain) | .Id ' | sed -e 's^/hostedzone/^^'
}

function waitForChangeToSync() {
	CHANGE_ID=$1 ; shift
	STATUS=$(aws --profile $PROFILE --region $REGION route53 get-change --id $CHANGE_ID --output text --query ChangeInfo.Status)
	while [ -n "$STATUS" ] && [ "$STATUS" == "PENDING" ]  ; do
		echo "INFO: waiting for sync of $*" >&2
		sleep 10
		STATUS=$(aws --profile $PROFILE --region $REGION route53 get-change --id $CHANGE_ID --output text --query ChangeInfo.Status)
	done
	if [ "$STATUS" == "INSYNC" ] ; then
		echo "INFO: $* in sync." >&2
	else
		echo "ERROR: failed to determine status of change $*." >&2
		exit 1
	fi
}

function createHostedZone() {
	local ID; local CHANGE_ID; local STATUS; local DOMAIN;

	DOMAIN=$1
	ID=$(getHostedZoneId $DOMAIN)
	if [ "$MODE" == "reuse" ] && [ -n "$ID" ] ; then
		echo "INFO: hosted zone $DOMAIN already exists" >&2
		echo $ID
	else
		echo "INFO: Creating hosted zone $DOMAIN " >&2
		CHANGE_ID=$(aws --profile $PROFILE --region $REGION route53 create-hosted-zone --name $DOMAIN --output text --query ChangeInfo.Id --caller-reference "asf-$(date +%Y%m%d%H%M%S)")
		if [ -n "$CHANGE_ID" ] && [ "None" != "$CHANGE_ID" ] ; then
			waitForChangeToSync "$CHANGE_ID" "hosted zone $DOMAIN"
			getHostedZoneId $DOMAIN
		else
			echo "ERROR: failed to created hosted zone $DOMAIN." >&2
			exit 1
		fi
	fi
}

function createKeyPair() {
        SSH_PRIVATE_KEY=$(pwd)/$STACK_DIR/$STACK_NAME.pem
        SSH_PUBLIC_KEY=${SSH_PRIVATE_KEY}.pub
	KEY_DESCRIPTION="$(aws --profile $PROFILE --region $REGION ec2 describe-key-pairs  --key-names $STACK_NAME 2>/dev/null)"

	setOpenSSL
	if [  -f $SSH_PRIVATE_KEY ] ; then
		if [ -n "$KEY_DESCRIPTION" ] ; then
			AWS_FINGERPRINT=$(echo "$KEY_DESCRIPTION" |  jq -r '.KeyPairs[0].KeyFingerprint')
			if [ $(wc -c <<< $AWS_FINGERPRINT) -eq 48 ] ; then
				# MD5 fingerprint of public key
				MY_FINGERPRINT="$(ssh-keygen -f $SSH_PUBLIC_KEY -e -m pem | \
						$OPENSSL rsa -RSAPublicKey_in -pubout -outform DER 2>/dev/null | \
						$OPENSSL md5 -c | sed 's/(stdin)= //')"
			else
				# SHA1 fingerprint of private key if key was generated by AWS
				MY_FINGERPRINT="$($OPENSSL pkcs8 -in $SSH_PRIVATE_KEY -nocrypt -topk8 -outform DER 2>/dev/null | $OPENSSL sha1 -c | sed 's/(stdin)= //')"
			fi
			if [ "$AWS_FINGERPRINT" != "$MY_FINGERPRINT" ] ; then
				echo ERROR: key pair $STACK_NAME already exist, but your private key has a different finger print. >&2
				echo ERROR:	Fingerprint in AWS is $AWS_FINGERPRINT, but local in $STACK_DIR is $MY_FINGERPRINT >&2
				exit 1
			fi
		else
			echo WARN: private key $STACK_NAME already exist, but it is not in AWS region $REGION. Importing. >&2
			aws --profile $PROFILE --region $REGION ec2 import-key-pair --key-name $STACK_NAME --public-key-material file://$SSH_PUBLIC_KEY > /dev/null || exit 1
		fi
	else
		if [ -z "$KEY_DESCRIPTION" ]  ; then
			echo "INFO: No private key file and no key pair in AWS. Generating and importing one." >&2
			mkdir -p $STACK_DIR
			SSH_PASS_PHRASE=$($OPENSSL rand -base64 12)
			ssh-keygen -q -t rsa -C "stack $STACK_NAME" -f $SSH_PRIVATE_KEY -N $SSH_PASS_PHRASE
			chmod 0700 $SSH_PRIVATE_KEY
			git add -f $SSH_PRIVATE_KEY $SSH_PUBLIC_KEY
			echo "NOTICE: generated private key with passphrase '$SSH_PASS_PHRASE'" >&2
			echo 'NOTICE: store this passphrase securily, or you will not be able to use the key.' >&2
			echo 'NOTICE: publish the encrypted key with `git commit` after stack creation.' >&2
			aws --profile $PROFILE --region $REGION ec2 import-key-pair --key-name $STACK_NAME --public-key-material file://$SSH_PUBLIC_KEY > /dev/null || exit 1
		else
			echo "ERROR: key pair $STACK_NAME already exist, but you do not have it in $STACK_DIR." >&2

			IN_USE=$(aws --profile $PROFILE --region $REGION ec2 describe-instances  | jq -r '.Reservations[] | .Instances[] | select(.State.Code!=48)| .KeyName' | sort -u | grep "^$STACK_NAME$")
			if [ -n "$IN_USE" ] ; then
				echo 	"	" "your colleague must have one, as there are instances still running with this key." >&2
			else
				echo 	"	" "I did not find any instances running with this key. If you are bold: you could delete it in AWS." >&2
				echo 	"	" "aws --profile $PROFILE --region $REGION ec2 delete-key-pair --key-name $STACK_NAME" >&2
			fi
			exit 1
		fi
	fi
}


function getServerCertificateId() {
    local NAME
    local CERTIFICATE_ID

    NAME=$1
    [ -z "$NAME" ] && echo "ERROR: missing domain name to get certificate id for" >&2 && exit 1

    CERTIFICATE_ID=$(
	   aws --profile $PROFILE --region $REGION iam list-server-certificates | jq --arg domain "$NAME" -r '.ServerCertificateMetadataList[] | select(.ServerCertificateName == $domain) | .Arn'
    )

    if [ -z "$CERTIFICATE_ID" ] ; then
	    echo "INFO: No server certificate found for domain '$NAME'" >&2
    else
	    echo "INFO: server certificate found for domain '$NAME'" >&2
    fi

    echo $CERTIFICATE_ID
}

initStackParameters() {
	cat > $STACK_DIR/stack-parameters <<!
KeyName=$STACK_NAME
DomainName=$(echo $DOMAIN_NAME | sed -e 's/\.*$/./')
Environment=$ENVIRONMENT
ExternalDomainName=$EXTERNAL_DOMAIN_NAME
ExternalHostedZoneId=$(getHostedZoneId $EXTERNAL_DOMAIN_NAME)
Project=$PROJECT
AWSProfile=$PROFILE
AWSRegion=$REGION
!

}

parseCommandLine "$@"
createKeyPair
EXTERNAL_HOSTED_ZONE_ID=$(createHostedZone $EXTERNAL_DOMAIN_NAME)
initStackParameters

bin/check-ns-records --domain-name $DOMAIN_NAME

echo "INFO: stack initialized. to create the base VPC:
     \$ bin/stack --create --domain-name $DOMAIN_NAME --template config/vpc/vpc.json"
